<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Meditation — captions required on images</title>

<style>
:root{
  --hue:0; --sat:85%; --lum:55%;
  --breath:8.5s;
  --surface-bg:rgba(0,0,0,.24);
  --caption-bg:rgba(0,0,0,.42);
  --text:#f5f7ff; --shadow:0 12px 32px rgba(0,0,0,.35);
}
/* Scene hues via data attribute (no JS array) */
:root[data-scene="1"]{ --hue:0;   --sat:85%; --lum:55% }
:root[data-scene="2"]{ --hue:28;  --sat:85%; --lum:55% }
:root[data-scene="3"]{ --hue:46;  --sat:85%; --lum:55% }
:root[data-scene="4"]{ --hue:96;  --sat:85%; --lum:55% }
:root[data-scene="5"]{ --hue:196; --sat:85%; --lum:55% }
:root[data-scene="6"]{ --hue:260; --sat:85%; --lum:55% }
:root[data-scene="7"]{ --hue:300; --sat:85%; --lum:55% }
:root[data-scene="8"]{ --hue:0;   --sat:5%;  --lum:96% }

*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%}
body{
  min-height:100%;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  color:var(--text);
  background:
    radial-gradient(circle at 20% 20%, rgba(110,30,30,.32), transparent 55%),
    radial-gradient(circle at 80% 80%, rgba(180,60,40,.28), transparent 60%),
    #1a0505;
  overflow:hidden;
}
@keyframes radiate{
  0%,100%{
    box-shadow:
      0 0 1.5vmax 0 hsla(var(--hue),var(--sat),var(--lum),.45),
      0 0 3vmax 0 hsla(var(--hue),var(--sat),var(--lum),.30),
      0 0 4.5vmax 0 hsla(var(--hue),var(--sat),var(--lum),.15);
  }
  50%{
    box-shadow:
      0 0 12vmax 6vmax hsla(var(--hue),var(--sat),var(--lum),.55),
      0 0 18vmax 9vmax hsla(var(--hue),var(--sat),var(--lum),.35),
      0 0 26vmax 13vmax hsla(var(--hue),var(--sat),var(--lum),.20);
  }
}
@keyframes fadeIn { from { opacity:0 } to { opacity:1 } }

main{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
.stage{
  display:flex;flex-direction:column;align-items:center;gap:20px;
  padding:16px 18px 24px;border-radius:18px;background:var(--surface-bg);
  border:3px solid hsla(var(--hue),var(--sat),var(--lum),.45);
  animation:radiate var(--breath) ease-in-out infinite;
  /* always visible; media nodes self-fade */
}
.media-node{display:block;max-width:78vw;max-height:68vh;object-fit:contain;animation:fadeIn .5s ease}
.caption{
  width:min(78vw,680px);padding:16px 22px;border-radius:16px;background:var(--caption-bg);
  text-align:center;line-height:1.5;backdrop-filter:blur(8px);box-shadow:var(--shadow);
  font-size:clamp(1rem,.75vw + .95rem,1.25rem)
}
.caption .hint{display:none;opacity:.85;font-size:.95em;margin-left:.5ch}
.stage[data-mode="choice"] .caption .hint{display:inline}

</style>

<main>
  <figure id="stage" class="stage" tabindex="0" aria-live="polite">
    <div id="mediaHost"></div>
    <figcaption id="captionBox" class="caption">
      <span id="captionText"></span>
      <span class="hint" aria-hidden="true">← / →</span>
    </figcaption>
  </figure>
</main>

<script>
/* ===== constants ===== */
const STILL_IMAGE_MS = 2500;

/* ===== storyboard =====
   step.type: 'image' | 'video'
   step.choiceKey: record 'left'/'right'
   step.dependsOn: read prior choice
   If BOTH dependsOn + choiceKey → reveal result THEN prompt next choice (no second still)
*/
const SCENES = [
  { id:'one', phases:{
    intro:{ type:'image', caption:"It's 7am. Time for our morning meditation.", src:'assets/checkpoints/1-1.png' },
    transition:{ type:'video', src:'assets/transitions/1.mp4' },
    outro:{ type:'image', caption:"I feel so relaxed. Let's get the day started.", src:'assets/checkpoints/1-2.png' },
  }},
  { id:'two', phases:{
    intro:{ type:'image', caption:"Drink maté at home or get breakfast with a friend?",
      left:'assets/checkpoints/2-1.png', right:'assets/checkpoints/2-1.png',
      captionLeft:"Drink maté at home", captionRight:"Get breakfast with a friend", choiceKey:'two-start' },
    transition:{ type:'video',
      left:'assets/transitions/2a.mp4', right:'assets/transitions/2b.mp4', dependsOn:'two-start' },
    // reveal chosen breakfast still, then prompt cold plunge vs garden (no preview)
    outro:{ type:'image', caption:"Cold plunge or read in the garden?",
      left:'assets/checkpoints/2-2a.png', right:'assets/checkpoints/2-2b.png',
      captionLeft:"I love maté!", captionRight:"My favorite food at Casa Chola.",
      dependsOn:'two-start', choiceKey:'two-end' },
  }},
  { id:'three', phases:{
    intro:{ type:'image',
      left:'assets/checkpoints/3-1a.png', right:'assets/checkpoints/3-1b.png',
      captionLeft:"Morning cold plunge at Lácar Lake.",
      captionRight:"It's such a beautiful day, let's read in the garden.", dependsOn:'two-end' },
    transition:{ type:'video',
      left:'assets/transitions/3a.mp4', right:'assets/transitions/3b.mp4', dependsOn:'two-end' },
    outro:{ type:'image',
      left:'assets/checkpoints/3-2a.png', right:'assets/checkpoints/3-2b.png',
      captionLeft:"Brrr so cold!", captionRight:"I love hearing the sound of the stream.", dependsOn:'two-end' },
  }},
  { id:'four', phases:{
    intro:{ type:'image', caption:"Breathwork with Paul and Erika today.", src:'assets/checkpoints/4-1.png' },
    transition:{ type:'video', src:'assets/transitions/4.mp4' },
    outro:{ type:'image', caption:"Breathing with the collective. Talk with the teachers or make lunch with friends?",
      left:'assets/checkpoints/4-2.png', right:'assets/checkpoints/4-2.png',
      captionLeft:"Talk with the teachers", captionRight:"Make lunch with friends", choiceKey:'five-path' },
  }},
  { id:'five', phases:{
    intro:{ type:'image',
      left:'assets/checkpoints/5-1a.png', right:'assets/checkpoints/5-1b.png',
      captionLeft:"Taking a moment to connect with Janne and Kaio, the meditation teachers.",
      captionRight:"Mmm what should we cook?", dependsOn:'five-path' },
    transition:{ type:'video',
      left:'assets/transitions/5a.mp4', right:'assets/transitions/5b.mp4', dependsOn:'five-path' },
    outro:{ type:'image',
      left:'assets/checkpoints/5-2a.png', right:'assets/checkpoints/5-2b.png',
      captionLeft:"Deepening my understanding of Buddhist meditation.",
      captionRight:"Eating tacos for lunch!", dependsOn:'five-path' },
  }},
  { id:'six', phases:{
    intro:{ type:'image', caption:"Heading to Le Village for a talk about vibecoding telegram chatbots.", src:'assets/checkpoints/6-1.png' },
    transition:{ type:'video', src:'assets/transitions/6.mp4' },
    outro:{ type:'image', caption:"We made a meditation chatbot!", src:'assets/checkpoints/6-2.png' },
  }},
  { id:'seven', phases:{
    intro:{ type:'image', caption:"Another day is over.", src:'assets/checkpoints/7-1.png' },
    transition:{ type:'video', src:'assets/transitions/7.mp4' },
    outro:{ type:'image', caption:"This is real life.", src:'assets/checkpoints/7-2.png' },
  }},
  { id:'eight', phases:{
    intro:{ type:'image', caption:"A new way of life?", src:'assets/checkpoints/8-1.png' },
    transition:{ type:'video', src:'assets/transitions/8.mp4' },
    outro:{ type:'image', caption:"This is real life.", src:'assets/checkpoints/8-2.png' },
  }},
];

/* ===== DOM ===== */
const rootEl = document.documentElement;
const stageEl = document.getElementById('stage');
const mediaHostEl = document.getElementById('mediaHost');
const captionBoxEl = document.getElementById('captionBox');
const captionTextEl = document.getElementById('captionText');

/* ===== State ===== */
const choiceByKey = Object.create(null); // choiceKey → 'left'|'right'
const mediaCache = new Map();            // url → Image|HTMLVideoElement

/* ===== Utilities ===== */
const isVideoUrl = u => /\.(mp4|webm|mov)$/i.test(u||'');
const wait = ms => new Promise(r=>setTimeout(r,ms));

/* ===== Rendering & playback ===== */
function mountMedia(node, text){
  if (node) node.classList.add('media-node');
  mediaHostEl.replaceChildren(node ?? []);
  captionTextEl.textContent = text || '';
  // make sure hint is hidden when not in choice mode
  stageEl.removeAttribute('data-mode');
}
function showChoiceCaption(text){
  captionTextEl.textContent = text || '';
  stageEl.setAttribute('data-mode','choice');
}
function waitForArrowChoice(){
  return new Promise(resolve=>{
    const onKey = e => {
      const k=e.key, left=(k==='ArrowLeft'||k==='Left'), right=(k==='ArrowRight'||k==='Right');
      if(!left && !right) return;
      removeEventListener('keydown', onKey);
      resolve(left ? 'left' : 'right');
    };
    addEventListener('keydown', onKey, { once:true });
  });
}

async function playAsset(url, captionText){
  const node = mediaCache.get(url);
  if(!node){ mountMedia(null, captionText); return; } // caption-only state
  if(isVideoUrl(url)){
    node.currentTime=0; node.loop=false;
    mountMedia(node, captionText);
    try{ await node.play(); }catch{}
    await new Promise(done=>node.addEventListener('ended',done,{once:true}));
  }else{
    mountMedia(node, captionText);
    await wait(STILL_IMAGE_MS);
  }
}

/* ===== Step Runner (reveal, choose, reveal→choose) ===== */
async function playStep(step, isIntro, captionCarryRef){
  const priorSide = key => choiceByKey[key] || 'left';
  const urlFor = side => (side ? step[side] : step.src) || step.src;
  const captionFor = side =>
    side ? ((side==='left'?step.captionLeft:step.captionRight) ?? step.caption ?? captionCarryRef.value ?? '')
         : (step.caption ?? captionCarryRef.value ?? '');

  // 1) Compound: reveal previous outcome, then prompt next choice (no second still)
  if (step.type==='image' && step.dependsOn && step.choiceKey){
    const side = priorSide(step.dependsOn);
    const revealUrl = urlFor(side);
    const revealText = captionFor(side);
    if (revealUrl) await playAsset(revealUrl, revealText);

    showChoiceCaption(step.caption);
    const nextSide = await waitForArrowChoice();
    choiceByKey[step.choiceKey] = nextSide;

    if (isIntro && !captionCarryRef.value) captionCarryRef.value = revealText || step.caption || '';
    return;
  }

  // 2) Choice-only: prompt, then show chosen still
  if (step.type==='image' && step.choiceKey){
    showChoiceCaption(step.caption);
    const side = await waitForArrowChoice();
    choiceByKey[step.choiceKey] = side;

    const chosenUrl = urlFor(side);
    const chosenText = captionFor(side);
    if (chosenUrl) await playAsset(chosenUrl, chosenText);

    if (isIntro && !captionCarryRef.value) captionCarryRef.value = chosenText || step.caption || '';
    return;
  }

  // 3) Reveal-only or plain media
  const side = step.dependsOn ? priorSide(step.dependsOn) : null;
  const url = urlFor(side);
  const text = captionFor(side);
  if (url) await playAsset(url, text);
  if (isIntro && !captionCarryRef.value) captionCarryRef.value = text || step.caption || '';
}

/* ===== Preload (fail-open) ===== */
function preload(url){
  return new Promise(ok=>{
    if (mediaCache.has(url)) return ok();
    if (isVideoUrl(url)){
      const v=document.createElement('video');
      Object.assign(v,{src:url,preload:'auto',muted:true,playsInline:true});
      const done=()=>{v.onloadeddata=v.onerror=null; mediaCache.set(url,v); ok();};
      v.onloadeddata=done; v.onerror=done; setTimeout(done,2000); v.load();
    }else{
      const i=new Image();
      i.onload=i.onerror=()=>{ mediaCache.set(url,i); ok(); };
      i.src=url;
    }
  });
}

/* ===== Orchestration ===== */
async function runShow(){
  stageEl.focus({ preventScroll:true });
  for (let i=0;i<SCENES.length;i++){
    // set hue via data attribute (CSS handles mapping)
    rootEl.dataset.scene = String(i+1);
    const { intro, transition, outro } = SCENES[i].phases;
    const captionCarry = { value:'' }; // intro caption flows through the scene
    await playStep(intro, true,  captionCarry);
    await playStep(transition, false, captionCarry);
    await playStep(outro, false, captionCarry);
  }
}

/* ===== Boot ===== */
stageEl.addEventListener('pointerdown', ()=>stageEl.focus({preventScroll:true}));

(async ()=>{
  const urls=[];
  for(const s of SCENES){
    for(const step of [s.phases.intro, s.phases.transition, s.phases.outro]){
      if(!step) continue;
      if(step.src) urls.push(step.src);
      if(step.left) urls.push(step.left);
      if(step.right) urls.push(step.right);
    }
  }
  await Promise.all(urls.map(preload)); // fail-open via timeouts
  runShow();
})();
</script>
</html>
